%include "boot.inc"
org	LOADER_BASE_ADDR
[section code]
[bits 16]
	mov	ax,cs
	mov	ds,ax
	mov	es,ax
	mov	ss,ax
	mov	sp,LOADER_BASE_ADDR
	call Get_Men
	mov	[MEM_SIZE],eax
	lgdt [GDT_PTR]
	cli
	in	al,0x92
	or	al,00000010b
	out	0x92,al
	mov	eax,cr0
	or	eax,1
	mov	cr0,eax
	jmp	dword SelectorCode:Code32

Get_Men:
	push bp
	mov	bp,sp
	sub	sp,0x200
	mov	di,sp
	sub	sp,4
	mov	dword [bp-0x204],0
	mov	edx,0x534d4150
	xor ebx,ebx
mem_loop:
	mov eax,0xe820
	mov	ecx,20
	int	0x15
	jc	mem_failed
	inc	dword [bp-0x204]
	add	edi,ecx
	cmp	ebx,0
	jnz	mem_loop
	sub	edi,ecx
	mov	ecx,[bp-0x204]
	xor	eax,eax
mem_max:
	mov	edx,[edi]
	add	edx,[edi+8]
	cmp	eax,edx
	jge	next_one
	mov	eax,edx
next_one:
	sub	edi,20
	loop mem_max
	leave
	ret
mem_failed:
	xor	eax,eax
	leave
	ret

[bits 32]
Code32:
	mov	ax,SelectorData
	mov	ds,ax
	mov	ss,ax
	mov	es,ax
	mov	esp,LOADER_BASE_ADDR
	mov	esi,pro_mode_msg
	mov	edi,80*2
	call print
	mov	eax,[MEM_SIZE]
	test eax,eax
	jnz	set_virtual_addr
	mov	esi,r_failed_msg
	mov	edi,80*2
	call print
	jmp	$
set_virtual_addr:
	mov	eax,VIRTUAL_ADDR_TABLE|ADDR_P|ADDR_RW
	mov	[VIRTUAL_DIR_TABLE],eax
	add	eax,0x1000
	mov	[VIRTUAL_DIR_TABLE+4],eax
	add	eax,0x1000
	mov	[VIRTUAL_DIR_TABLE+8],eax
	mov	ecx,1021
	mov	edi,VIRTUAL_DIR_TABLE+12
loop_zero:
	mov dword [edi],0
	add	edi,4
	loop loop_zero

	mov	eax,0 | ADDR_P | ADDR_RW
	mov	edi,VIRTUAL_ADDR_TABLE
	mov	ecx,1024*3
set_virtual_table:
	mov	[edi],eax
	add	eax,0x1000
	add	edi,4
	loop set_virtual_table
	mov	eax,VIRTUAL_DIR_TABLE
	mov	cr3,eax
	mov	eax,cr0
	or	eax,0x80000000
	mov	cr0,eax
	mov	esi,vir_addr_msg
	mov	edi,80*4
	call print
	mov	eax,KERNEL_START_SECTOR
	mov	ebx,KERNEL_BASE_ADDR
	mov	ecx,KERNEL_LENGTH
	call rd_disk_m_32
	mov	esi,kernel_in
	mov	edi,80*6
	call print
	call elf_mov
;	lidt [IDT_PTR]
;	call init_8259A
;	mov	al,11111110b
;	out	0x21,al
;	mov	al,0xff
;	out	0xa1,al
;	sti
	mov	esp,KERNEL_BASE_ADDR
	mov	eax,[KERNEL_BASE_ADDR+24]		;elf header entry
	jmp	eax								;jmp and nerver back

elf_mov:
	mov	eax,KERNEL_BASE_ADDR
	mov	cx,[eax+44]
	mov	ebx,[eax+28]					;phoff
.1:
	push ecx
	mov	esi,[eax+ebx+4]					;p_offset
	add	esi,eax
	mov	ecx,[eax+ebx+16]				;p_filesz
	mov	edi,[eax+ebx+8]					;p_vaddr
	add	edi,eax
	rep movsb
	add	ebx,32
	pop	ecx
	loop .1
	ret

;-------------------------------------------------------------------------------
			   ;功能:读取硬盘n个扇区
rd_disk_m_32:	   
;-------------------------------------------------------------------------------
							 ; eax=LBA扇区号
							 ; ebx=将数据写入的内存地址
							 ; ecx=读入的扇区数
      mov esi,eax	   ; 备份eax
      mov di,cx		   ; 备份扇区数到di
;读写硬盘:
;第1步：设置要读取的扇区数
      mov dx,0x1f2
      mov al,cl
      out dx,al            ;读取的扇区数

      mov eax,esi	   ;恢复ax

;第2步：将LBA地址存入0x1f3 ~ 0x1f6

      ;LBA地址7~0位写入端口0x1f3
      mov dx,0x1f3                       
      out dx,al                          

      ;LBA地址15~8位写入端口0x1f4
      mov cl,8
      shr eax,cl
      mov dx,0x1f4
      out dx,al

      ;LBA地址23~16位写入端口0x1f5
      shr eax,cl
      mov dx,0x1f5
      out dx,al

      shr eax,cl
      and al,0x0f	   ;lba第24~27位
      or al,0xe0	   ; 设置7～4位为1110,表示lba模式
      mov dx,0x1f6
      out dx,al

;第3步：向0x1f7端口写入读命令，0x20 
      mov dx,0x1f7
      mov al,0x20                        
      out dx,al

;;;;;;; 至此,硬盘控制器便从指定的lba地址(eax)处,读出连续的cx个扇区,下面检查硬盘状态,不忙就能把这cx个扇区的数据读出来

;第4步：检测硬盘状态
  .not_ready:		   ;测试0x1f7端口(status寄存器)的的BSY位
      ;同一端口,写时表示写入命令字,读时表示读入硬盘状态
      nop
      in al,dx
      and al,0x88	   ;第4位为1表示硬盘控制器已准备好数据传输,第7位为1表示硬盘忙
      cmp al,0x08
      jnz .not_ready	   ;若未准备好,继续等。

;第5步：从0x1f0端口读数据
      mov ax, di	   ;以下从硬盘端口读数据用insw指令更快捷,不过尽可能多的演示命令使用,
			   ;在此先用这种方法,在后面内容会用到insw和outsw等

      mov dx, 256	   ;di为要读取的扇区数,一个扇区有512字节,每次读入一个字,共需di*512/2次,所以di*256
      mul dx
      mov cx, ax	   
      mov dx, 0x1f0
  .go_on_read:
      in ax,dx		
      mov [ebx], ax
      add ebx, 2
			  ; 由于在实模式下偏移地址为16位,所以用bx只会访问到0~FFFFh的偏移。
			  ; loader的栈指针为0x900,bx为指向的数据输出缓冲区,且为16位，
			  ; 超过0xffff后,bx部分会从0开始,所以当要读取的扇区数过大,待写入的地址超过bx的范围时，
			  ; 从硬盘上读出的数据会把0x0000~0xffff的覆盖，
			  ; 造成栈被破坏,所以ret返回时,返回地址被破坏了,已经不是之前正确的地址,
			  ; 故程序出会错,不知道会跑到哪里去。
			  ; 所以改为ebx代替bx指向缓冲区,这样生成的机器码前面会有0x66和0x67来反转。
			  ; 0X66用于反转默认的操作数大小! 0X67用于反转默认的寻址方式.
			  ; cpu处于16位模式时,会理所当然的认为操作数和寻址都是16位,处于32位模式时,
			  ; 也会认为要执行的指令是32位.
			  ; 当我们在其中任意模式下用了另外模式的寻址方式或操作数大小(姑且认为16位模式用16位字节操作数，
			  ; 32位模式下用32字节的操作数)时,编译器会在指令前帮我们加上0x66或0x67，
			  ; 临时改变当前cpu模式到另外的模式下.
			  ; 假设当前运行在16位模式,遇到0X66时,操作数大小变为32位.
			  ; 假设当前运行在32位模式,遇到0X66时,操作数大小变为16位.
			  ; 假设当前运行在16位模式,遇到0X67时,寻址方式变为32位寻址
			  ; 假设当前运行在32位模式,遇到0X67时,寻址方式变为16位寻址.

      loop .go_on_read
      ret
print:
	mov	ax,SelectorVideo
	mov	gs,ax
	mov	ah,0xc
print_text:
	mov	al,[esi]
	inc	esi
	mov	[gs:edi],ax
	add	edi,2
	test al,al
	jnz	print_text
	ret

;init_8259A:
;	mov	al,0x11
;	out	0x20,al
;	out	0xa0,al
;
;	mov	al,0x20
;	out	0x21,al
;	mov	al,0x28
;	out	0xa1,al
;	
;	mov	al,0x4
;	out	0x21,al
;	mov	al,0x2
;	out	0xa1,al
;	
;	mov	al,0x3
;	out	0x21,al
;	out	0xa1,al
;	ret

;Time_handler:
;Time_handler_off	equ Time_handler-$$+LOADER_BASE_ADDR
;	inc	byte[gs:0]
	;mov	al,0x20
	;out	0x20,al
;	iretd

[section gdt]
;gdt						base,	limit,		attribute
GDT			:Seg_Desc		0,		0,			0
CODE_DESC	:Seg_Desc		0,		0xfffff,		DA_C+DA_32+LIMITE_32+DES_PRESENT
DATA_DESC	:Seg_Desc		0,		0xfffff,		DA_DRW+LIMITE_32+DES_PRESENT
VIDEO_DESC	:Seg_Desc		0xb8000,0xffff,		DA_DRW+DES_PRESENT
;gdt end
GDT_LEN		equ $-GDT
GDT_PTR		dw	GDT_LEN-1
			dd	GDT
;idt						selector,		offset,		attribute
;IDT:
;%rep 0x100
;			Gate_Desc		SelectorCode,	Time_handler_off,	DES_PRESENT+GATE_INT+DES_DPL_0
;%endrep
;idt end
;IDT_LEN		equ $-IDT
;IDT_PTR		dw	IDT_LEN-1
;			dd	IDT

SelectorCode	equ CODE_DESC-GDT
SelectorData	equ DATA_DESC-GDT
SelectorVideo	equ VIDEO_DESC-GDT
pro_mode_msg	db	"Now we are in protected mode",0
vir_addr_msg	db	"Now we are in virtual addr",0
kernel_in		db	"Now kernel is in memory",0
r_failed_msg	db	"reading failed,,,hlt",0
